# package: data.table

### Обращение к элементам data.table, как правило, возвращает объект data.table
* Обращение к колонками по их номерам (как при работе с data.frame) не рекомендуется — нужно указывать имена столбцов.
* `dt[2]` вернет *data.table*, содержащий вторую строку (`df[2]` вернет второй столбец как *data.frame*).
* `dt[2, 2]` вернет *data.table*, содержащий одно значение второй строки второго столбца (`df[2, 2]` вернет вектор размера 1).
* `dt[["Col2"]]` или `dt[[2]]` : самый быстрый способ вернуть вектор-столбец из объекта data.table.
* `dt[, X + Y]` вернет вектор (т.к. названия столбцов трактуются как обычные переменные), тогда как `dt[, .(X + Y)]` вернет *data.table*.
* Для использования синтаксиса data.frame в объектах data.table в операторе `[ ]` необходимо указать аргумент `with = FALSE`.
* Чтобы вернуть столбцы, названия которых заданы значениями переменной `x` для data.frame достаточно указать `df[, x]`. Для data.table необходимо использовать `dt[, x, with = FALSE]` (иначе будет искаться столбец с названием `x`). Чтобы вернуть один столбец, название которого задано переменной `x` можно использовать синтаксис `dt[[x]]`.\
Опция `options(datatable.WhenJisSymbolThenCallingScope=TRUE)` изменяет поведение по умолчанию для data.table на поведение, аналогичное поведению data.frame.
* `X[Y, sum(foo*bar), by = .EACHI]` : группирует результат соединения по каждому значения ключа

### Выборка столбцов
```r
dt[ , .(x, y, z)]
dt[, c("x","y","z")]
dt[, cols, with = FALSE)   ; вернуть столбцы, названия которых заданы переменной cols
```

* `.SD` : *Subset of the Data.table* – ссылается на все столбцы, за исколючением столбцов группировки. Может быть переопределено аргументом `SDcols`.
* `dt[0]` : возвращает пустую таблицу со структурой как в dt (может использоваться как создание таблицы по шаблону).
* Группирующая переменная, если используется в выражении `j`, всегда имеет размерность 1.
* Чтобы вывести нужное количесво строк можно использовать `print(dt, topn = 20)`.
 
>*Для получения некоторого набора элементов из массива в виде вектора необходимо использовать синтаксис* `dt[mx]`*, где* `mx` *это матрица с количеством столбцов равным количеству индексов в массиве, а каждая строка матрицы представляет собой индексы извлекаемых элементов. Вместо числовых индексов также можно использовать именна для строк и столбцов матрицы.*

* При соединении таблиц аргумент `nomatch = NA` осуществит *outer join*, аргумент `nomatch = NULL` — *inner join*, аргумент `mult = "first"|"last"` выберет из каждой группы первую|последнюю запись.
* `dt[NA]` вернет одну строку со значениями `NA` для всех столбцов. То же самое вернет `dt[i]`, если значение `i` превышает число строк в таблице.
* `dt[0]` или `dt[FALSE]` вернут пустую таблицу той же структуры, что и `dt`.
* Чтобы получить вывод таблицы, содержащей операцию `:=` нужно добавть в конце `[]`.
* Создание индекса в таблице не увеличивает потребность в RAM. Производиться только пересортировка строк таблицы и помечаются столбцы, входящие в индекс (все аналогично clustered index в SQL). Вторичные индексы занимают дополнительные `4*nrow` байт в памяти. Как правило, они создаются автомитически при задании логических условий в `i`, использующих операторы `==` и `%in%`.
* 

## Дополнительншые аргументы в операторе [
* mult
* roll
* .EACHI
* SDCols
* 
