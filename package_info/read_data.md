## Чтение данных в R

### Пакет vroom
``` r
df <- vroom("./dfata.csv")           ; чтение из csv-файла (разделитель определяются автоматически, но могут быть указн яыно)
df <- vroom("Https://.../data.csv")  ; чтение данных из URL
files <- dir(pattern = "./*.xls$")   ; список xls-файлов в текущей директории
df <- vroom(files)                   ; чтение данных из всех файлов списка в один датафрейм
```


### Пакет readxl
*Чтение данных из файла Excel. Cчитанные данные возврашаются в видте объекта `tibble`. Пакет не предназначен для записи данных в файлы Excel.*
``` r
library(readxl)
df <- read_excel("./data.xls",             ; прочитать данные из указанного файла
                 sheet = "Sheet1",         ; прочитать данные с листа 2 (вместо названия также можно указать номер листа)
                 col_names = TRUE,         ; признак наличия заголовков столбцов или вектор с названиями, которые будут присвоены
                 col_types = NULL,         ; типы столбцов ("skip"|"guess"|"logical"|"numeric"|"date"|"text"|"list") - может быть указано одно значение для всех (recycled)
                 range = "C1:E4",          ; прочитать указанный диапазон
                 range = cell_cols("B:D"), ; прочитать указанные столбцы
                 n_max = 3,                ; прочитать только 3 строки,
                 skip = 2,                 ; пропускать первые 2 строки
                 trim_ws = TRUE            ; удалять ведущие и конечные пробелы
                 na = ''                   ; заменять пропущенные значения указанным символьным значением (по умолчанию NA)
)

# чтение всех листов книги Excel в один объект
list_sheets <- readxl::excel_sheets("./data.xls")  ; список листов в указанном файле Excel
df_book <- sapply(list_sheets,
                  read_excel,
                  path = "data.xlsx")
df_books[["Sheet2"]]                               ; обращение к датафрейму листа "Sheet2"

# вертикальное объединение датафреймов
df_total <- dplyr::bind_rows(df1, df2, df3)

```

### Пакет dplyr
#### Основные функции конвейера обработки данных
``` r
df %>%
  select(col1, col2, col4, col5) %>%  ; отбор столбцов
  filter(col2 >= 4 & col5 < 100) %>%  ; фильтрация строк
  mutate(col6 = col1 + col4)     %>%  ; добавление вычисляемых столбцов
  group_by(col2, col4)           %>%  ; создание подгрупп данных
  summarise(col5 = sum(col5))    %>%  ; вычисление значений по подгруппам
  arrange(desc(col2), col4)      %>%  ; сортировка
```

#### `mutate()`
Если в функции `mutate()`, которая вычисляется после применения `group_by()`, для значений нового столбца использовать агрегирующую функцию, то кол-во строк в датафрейме не уменьшится, а результатом будет вычисление подитога (== расчету подитога оконной функцией). Для оконных операций часто используются функции `min_rank()`, `dense_rank()`, `cumsum()`.

### Дополнительные примеры использования
``` r
filter(grepl("^2022", month))   ; отобрать строки, у которых month начинается с "2022"
filter(rank == max(rank))       ; отобрать строки с максимальным значением столбца rank
lag(col2, order_by = month)     ; получает значения столбца col2 для предыдущего месяца
lead(col2, order_by = month)    ; получает значения столбца col2 для следующего месяца
```

#### Прочие фукции пакета
``` r
distinct(df$col2)   ; возвращает уникальные значения в указанноми столбце
```

### Пакет tidyr
``` r
fill(df, col2, .direction = "down")  ; последовательно заполняет пропущенные данные предыдущими значениями
replace_na(df, value)                ; заменяет значения NA на value
pivot_longer(df,                     ; перевести таблицу из широкого формата в длинный
             cols = 'col2':'col8',   ;   столбцы, которые нужно "развернуть" в строке
             names_to = "month",     ;   назвать развернутый столбец "month"
             values_to = "sales")    ;   в качестве значений использовать значения из столбца "sales"  
separate(df,                         ; разделяет текстовый столбец на несколько по разделителю данных
         col = "month",              ;   столбец для разделения
         into = c("month", "year"),  ;   названия новых столбцов
         remove = TRUE,              ;   удалить исходный столбец
         sep = " ")                  ;   в качестве разделителя использовать пробел
pivot_wider(df,                      ; перевести таблицу из длинного формата в широкий
            names_from = year,       ;   столбец с названиями новых столбцов
            value_from = sales)      ;   столбец со значениями новых столбцоа
w_spec <- build_wider_spec(df,       ; сохраняет логику преобразования датафрейма df к широкому формату в переменную
                 names_from = SaleType,
                 value_from = Summa)
pivot_wider_spec(df, spec = w_spec)  ; перевести таблицу из длинного формата в широкий, используя сохраненную спецификацию преобразования
saveRDS(object = w_spec,             ; сохранить спецификацию в файл
                 file = "spec.rds")
w_spec = readRDS("spec.rds")         ; восстановить спецификаию из файла  
``` 
