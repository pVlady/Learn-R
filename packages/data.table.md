# data.table
- Установка ключа функцией `setkey()` **всегда** делает inplace-сортировку таблицы по *возрастанию* значений ключа.
- При соединении таблиц вида `a[b]` можно не указывать аргумент `on`, если таблица `a` имеет ключ — по нему и будет выполняться соединение.
- Выражение вида `a[b, bb:=i.B]` добавит в таблицу `a` столбец `bb` со значениями столбца `B` из таблицы `b`. Где не будет совпадения по ключу, добавятся значения `NA`. То же самое будет в случае, если `b` является списком, а не объектом data.table.

### Значения аргументов по умолчанию для функций `data.table()` и `[]`
```r
data.table(...,                      ; как в data.frame
           keep.rownames = FALSE,    ; если TRUE и ... являются матрицей или data.frame, имена строк сохраняются в столбце
           check.names = FALSE,      ; как в data.frame
           key = NULL,               ; может быть представлен строкой вида "x,y,x" или вектором c("x","y","z")
           stringsAsFactors = FALSE) ; как в data.frame, но по умолчанию равен FALSE

# S3 method for data.table
[(x,                        ; x - data.table
  i,                        ; integer, logical or character vector; single column numeric matrix; expression of column names; list; data.frame or data.table; имя переменной                   
  j,                        ; список (в т.ч. вычисляемый), каждый элемент которого станет столбцом результирующей data.table
  by, keyby,                ; переменные группировки
  with = TRUE,              ; если FALSE, то синтаксис трактуется как синтаксис data.frame
  nomatch = NA,
  mult = "all",
  roll = FALSE,
  rollends = if (roll=="nearest") c(TRUE,TRUE)
             else if (roll>=0) c(FALSE,TRUE)
             else c(TRUE,FALSE),
  which = FALSE,
  .SDcols,
  verbose = getOption("datatable.verbose"),                   # default: FALSE
  allow.cartesian = getOption("datatable.allow.cartesian"),   # default: FALSE
  on = NULL, env = NULL)
```
* Если в `i` встречается значение `NA`, то оно трактуется как FALSE (в отличие от data.frame).
*  В `i` аргументы типа _character_, _list_ and _data.frame_ преобразуются в _data.table_. В этом случае для соединения таблиц должен быть указан аргумент `on` (рекомендуется указывать всегда), либо в таблице `x` должен быть определен ключ. При наличии ключа в таблице 'i', соединение производится по совпадению ключей. В противном случае используется совпадение _первого столбца ключа_ таблицы `x` _с первым столбцом_ 'i', вторго -- со вторым и т.д.
* Если в `i` указано имя переменной, определенной в области видимости, то ее значения не рассматриваются как названия столбцов, и она не преобразуется в data.table, а использется как есть.
* Если `j` не явяяется списком, то он возвращается как есть, напр., `dt[, x]`, если не используется аргумент `by`. В последнем случае `j` неявно преобразуется в список.\
  Если `j` представлено вектором названий или индексов столбцов, то они используются как есть без необходимости устанавливать аргумент `with = FALSE`. В то же время этот аргумент нужно использовать, если `j` представлен логическим вектором _с длиной равной числу столбцов исходной data.table_.
* Если `i` является _data.table_, то столбцы этой таблицы могут использоваться в `j` с префиксом `i.`. Для обеспечения ясности одноименные столбцы исходной таблицы могут использовать префикс `x.`.
* Переменная группировки `by` может быть представлена отдельным столбцом (без кавычек), строкой вида `by="x,y,z"`, символьным вектором названий столбцов, диапазоном столбцов вида `by=x:z` или списком (в т.ч. вычисляемым, напр., `by = .(x = x>0, y)`). Если `i` является _data.table_ | _data.frame_ | _list_, то выражение `dt[i, j, by=.EACHI]` выполняет группировку `dt` по каждой строке в `i`, т.е. одновременно выполняет и соединение, и группировку.
* В выражении `dt[i]`, когда `i` является _data.table_, сначалв выводятся столбцы `dt`, потом столбцы `i`.
* Выражение вида `dt[i, j]`, когда `i` является _data.table_, позволяет сразу определить необходимые столбцы соединения, что является более производительным, чем отбирать их позже.
* Аргумент `keyby` аналогичен `by` с той разницей, что предварительно выполняется `setkey()` по указанным столбцам. Как правило, исполльзуется в случае, если необходимо получить отсортированный по ключу результат.
* Аргумент `nomatch=NA` (значение по умолчанию) означает, что для строк `i` в соединении `dt[i]`, которым не найдено соответствие в `dt`, будет возвращаться `NA`. Если `nomatch=NULL`, то такие строки не будут возвращаться вовсе (т.е. получим INNER JOIN).
* Аргумент `mult` используется для соединений и в случае, если одной строке в `i` соответствует несколько строк `dt`, определяет, какие строки будут возвращаться: _all_ | _first_ | _last_.
* Аргумент `roll` используется в случае скользящего соединения, и определяет способ соединения, если совпали все столбцы соединения, кроме последнего :
  * `+Inf` (или `TRUE`) соединяет со строкой x в направлении вперед (last observation carried forward - LOCF).
  * `-Inf` то же, но в направлении назад (next observation carried backward - NOCB).
  * положительное или отрицательное число ограничивает, насколько далеко вперед или назад может находиться искомая строка.
  * `"nearest"` ищет ближайшее значение.

>Скользящее соединение применяется только к последнему из соединяемых столбцов, как правило представленного датой (но может быть любой переменной).

* Аргумент `rollends` является логическим вектором длины 2 и определяет, включать или нет в соединение строку перед первой | строку после последней, для которых фактическое соединение отсутствует.
* Аргумент `which`:
  * `TRUE` вернет номера строк x, которые есть в `i`.
  * `NA` вернет номера строк `i`, которых нет в `dt`.
  * `FALSE` (по умолчанию) вернет строки `dt`, которые найдены в`i`.
* Аргумент `SDcols` определяет столбцы `dt`, которые будет содержать специальная переменная `.SD`. Может быть символьным вектором названий столбцов или номеров их позиций; логическим вектором; функцией вида `is.numeric` или `patterns()`. `.SDcols` особенно полезен для применения функции к подмножеству столбцов по группам: `dt[, lapply(.SD, sum), by="x,y", .SDcols=301:350]`. Столбцы для включения в `.SD` можно указать с помощью регулярного выражения, применяемого к названиям столбцов: `.SDcols = patterns(regex1, regex2, ...)` -- будут отобраны столбцы, названия которых удовлетворяют всем регулярным выражениям (условие _or_ реализуется с помощью `|` в самом регулярном выражении). Условие можно инвертировать `.SDcols = !is.numeric`. Вместо указания, какие столбцы включить в `.SD`, можно указать, какие столбцы включать не нужно: `.SDcols = !c('x', 'y')`.
* Аргумент `verbose` включает вывод информационных сообщений в консоль. Может быть включен по умолчанию посредством `options(datatable.verbose=TRUE)`.
* Аргумент `allow.cartesian = FALSE` предотвращает соединения, которые имеют более, чем `nrow(dt) + nrow(i)` строк. Это случается, если `i` имеет дубли в стоолбцах соединения.
* Аргумент `on` определяет столбцы соединения. Имеет приоритет над ключами таблиц `dt` и `i`. Может быть:
  * неименованным символьным вектором названий столбцов (общих для обеих таблиц): `dt[i, on = c("a", "b")]`.
  * именованным символьным вектором, если названия столбцов отличаются в таблицах `dt` и `i`: `dt[i, on = c(x1 = "y1", x2 = "y2")]`, соединение столбцов `x1` и `x2` таблицы `dt` со столбцами `y1`, `y2` таблицы `i`. То же самое также можно указать как `dt[i, on = c("x1 == y1", "x2 == y2")]`. 
  * комбинацией указвнных выше случаев, если в соединении имеются как общие, так и различные столбцы: `dt[i, on = c("a", V2 = "b")]`.
  * списком `dt[i, on = .(a, b)]`.
  * выражением вида `dt[i, on = c("x >= a", "y <= b")]`, либо for interactive `dt[i, on = .(x >= a, y <= b)]` для non-equal join.
* Аргумент `env` определяет list or an environment, passed to substitute2 for substitution of parameters in i, j and by (or keyby). Use verbose to preview constructed expressions.

### Общие функции
```r
nrow(dt)     ; число строк в таблице
ncol(dt)     ; число столбцов в таблице
names(dt)    ; названия столбцов таблицы
setDT(df)    ; inplace-преобразование датафрейма в объект data.table
setDF(dt)    ; inplace-преобразование объекта data.table в датафрейм
```
### Параметры по умолчанию оператора `[`
```r
[(dt, i, j, by, keyby,
  with = TRUE,
  nomatch = NA,
  mult = "all",
  roll = FALSE,
  rollends = if (roll == "nearest") c(TRUE, TRUE) else if (roll >= 0) c(FALSE, TRUE) else c(TRUE, FALSE),
  which = FALSE,
  .SDcols,
  verbose = getOption("datatable.verbose"),                   ; default: FALSE
  allow.cartesian = getOption("datatable.allow.cartesian"),   ; default: FALSE
  drop = NULL, on = NULL, env = NULL)
```
Кроме `i`, `j`, `by` в выражении `dt[i, j, by]` могут использоваться:
* `with`, `which` — `with = FALSE` использовать синтаксис *data.frame* при обращении к *data.,table*
* `allow.cartesian`
* `roll`, `rollends` — для скользящих соединений таблиц
* `.SD`, `.SDcols` — для указания столбцов, с которыми должны производиться операции (***S**ubset of **D**ata.Table*)
* `on` — для указания столбцов, по которым производиться соединение
* `mult` = `"first"`|`"last"` — позволяет выбрать первую|последнюю запись в группе
* `nomatch` — для выбора типа соединения таблиц (`nomatch = NA|NULL` : `outer join`|`inner join`)
* `.EACHI` — выполняет группировку по каждому значению в выражении соединения. По сути это замена выражения `X[Y, .(foo, bar)][, sum(foo*bar)]` на `X[Y, sum(foo*bar), by=.EACHI]`

### Удаление дубликатов
* Если для таблицы `dt` установлен ключ, то вызов `unique(dt)` вернет уникальные значения ключа.
* Если ключ отсутствует, то `unique(dt)` вернет уникальные строки таблицы.

### Операции со стороками
```r
dt[x %between% c(7,9)]
dt[!x %in% c("JFK", "LGA")]
; или так
setkey(dt, x)
dt[c("JFK", "LGA")]
;
setkey(dt, x, y)
dt[.("JFK", "MIA")]

nafill(dt, type = "const", fill = 0.00)     ; заполняет пропущенные значения указанной константой
nafill(dt, type = "locf")                   ; заполняет пропуски данных предыдущим значением
setnafill(dt, "locf", cols = c("v2","v3"))  ; заполняет пропуски в указанных столбцах предыдущими значениями

# удаление строк с пропущенными значениями
na.omit(dt)                    ; удаление строк, в которых есть значения NA или NaN
na.omit(dt, cols = "x")        ; удаление строк с пропущенными значениями в столбце  `x`
na.omit(dt, cols=c("x", "y"))  ; удаление строк с пропущенными значениями в столбцах `x` или `y`
```

### Операции со столбцами
```r
dt[, c(2)]                                ; вернет второй столбец
dt[, col1]                                ; вернет один столбец как вектор
dt[, .(x, y, z)]                          ; вернет несколько столбцов как новый data.table
dt[, 1:3, with = FALSE]                   ; первые три столбца (синтаксис data.frame)
dt[, c("x","y","z"), with = FALSE]        ; вернуть указанные столбцы (синтаксис data.frame)
dt[, cols, with = FALSE)                  ; вернуть столбцы, названия которых заданы переменной cols
dt[, !c("x, "y"), with = FALSE]           ; вернуть все столбцы кроме столбцов x и y
dt[, names(dt) %like% "dep", with=FALSE]  ; вернуть столбцы, названия которых удовлетваряют образцу
dt[, col2: = NULL]                        ; удалить столбец col2
setnames(dt, c("col1", "col2"),           ; перерименовать столбцы col1 и col2 в COL1 и COL2
             c("COL1", "COL2"))
setkey(dt, col1, col2)                    ; создать ключ по столбцам (col1, col2) (таблица сортируется по ключу!)
```
* `.SD` : *Subset of the Data.table* – ссылается на все столбцы, за исключением столбцов группировки. Может быть переопределено аргументом `SDcols`.
* Группирующая переменная, если используется в выражении `j`, всегда имеет размерность 1 и содержит значение группы.
* Чтобы вывести нужное количесво строк функцией `print()` можно использовать `print(dt, topn = 20)`.
 
>*Для получения некоторого набора элементов из массива в виде вектора необходимо использовать синтаксис* `dt[mx]`*, где* `mx` *это матрица с количеством столбцов равным количеству индексов в массиве, а каждая строка матрицы представляет собой индексы извлекаемых элементов. Вместо числовых индексов также можно использовать имена для строк и столбцов матрицы.*

### Создание, переименование и изменение порядка столбцов
```r
dt[, col4 := ifelse(col2 < 50, 0, 1)]               ; inplace-создание одного столбца
dt[, `:=`(col4 = sqrt(col2), col5 = col1 + col2]    ; inplace-создание нескольких столбцов
dt[, c("col4","col5"):=.(sqrt(col2), col1 + col2)]  ; то же самое

setnames(dt, c("col1", "col2"), c("new1", "new2"))  ; inplace переименование столбцов
setcolorder(dt, c("col3", "col2", "col1")           ; inplace изменение порядка столбцов (могут быть указаны только несколько первых, остальные не меняются)
```
### Сортировка таблицы
> В отличие от объектов _data.frame_ при сортировке таблицы _data.table_ строки со значениями `NA` по умолчанию помещаются в начало таблицы.
```r
dt[order(col4)]                                                ; сортировка по столобцу col4
dt[order(-col2, col4)]                                         ; сортировка по нескольким столбцам
dt[order(factor(col4, levels = vec))]                          ; сортировка по заданному порядку значений вектора vec, содержащего значения столбца col4
dt[order(col4 != "Hornet Sportabout")]                         ; сортировка по совпадению значения столбца с заданным выражением
dt[order(col4, ifelse(col4 == 1, -col2, col2))]                ; сортировка по сложному выражению (col2 - числовой столбец)
dt[order(col4, ifelse(col4 == 1, -xtfrm(col2), xtfrm(col2)))]  ; сортировка по сложному выражению (col2 - текстовый столбец)
dt[do.call("order", unname(dt[, -1]))]                         ; сортировка по всем столбцам кроме первого

# сортировка по вектору названий столбцов в указанном порядке
cols <- c("col2", "col4")
sort_vec <- unname(dt[, ..cols])
dt[do.call("order", sort_vec)]

# setorder function — inplace сортировка
setorder(dt, -x, y, na.last = TRUE)       ; сортировка по нескольким столбцам (NA помещаются в конец таблицы)
```

### Группировка
```r
dt[, lapply(.SD, mean)]                            ; вычисление среднего для всех столбцов
dt[, lapply(.SD, mean), .SDcols = c("x", "y")]     ; вычисление среднего для указанных столбцов
dt[, .SD[1:3], by = x]                             ; первые три строки в сгруппированных по x данных
dt[, .SD[.N], by = x]                              ; последняя строка в сгруппированных по x данных
dt[, rank:=frank(-y,ties.method = "min"), by = x]  ; ранжирование в обратном порядке y внутри групп x
unique(dt, by = c("col1", "col2"))                 ; выборка уникальных строк для сочетаний значений col1 и col2
```
Если вместо аргумента `by` использовать аргумент `keyby`, то вместе с группировакой результат будет отсортирован по созданному ключу.

### Сдвиг данных в таблице
```r
dt[ , x2 := shift(x, 1, type="lag")]
dt[ , x3 := shift(x, 1, type="lead")]
```

### Соединения таблиц
Соединяемые таблицы должны иметь ключ по столбцам соединения, либо столбцы соединения должны быть указаны аргументом `by` функции `merge()` или аргументом `on` для соединений в операторном виде.\
Операции вида `dt[Y]` используют `Y` (или ключ `Y`, если `Y` data.table) как индекс для отображения строк таблицы `dt`.
```r
merge(dt1, dt2, by = "x")                ; INNER JOIN        ; dt1[dt2, nomatch = NULL]
merge(dt1, dt2, by = "x", all.x = TRUE)  ; LEFT JOIN         ; dt2[dt1]
merge(dt1, dt2, by = "x", all.y = TRUE)  ; RIGHT JOIN        ; dt1[dt2]
merge(dt1, dt2, all = TRUE)              ; FULL OUTER JOIN   ; dt1[dt2, nomatch = NA]

dt[x, on="id"]               ; right join    : SELECT DT RIGHT JOIN X (одноименные столбцы x переименовываются с добавлением `i.`)
x[dt, on="id"]               ; left join     : SELECT X RIGHT JOIN DT ON DT$id != X$id
dt[x, on="id", nomatch = 0]  ; inner join    : SELECT DT INNER JOIN X ON DT$id != X$id
dt[!x, on="id"]              ; not join      : SELECT DT LEFT JOIN X ON DT$x != X$x
dt[x, on=.(id <= foo)]       ; non-equi join : SELECT DT RIGHT JOIN X ON DT$id <= X$foo
dt[x, on = "y <= foo"]       ; same as above
dt[x, on = c("y <= foo")]    ; same as above
dt[x, .(id, v, i.id, i.foo), ; указать, какие столбцы нужно вернуть
      on=.(id, y >= foo)]
dt[x, on=.(id, y <= foo)]    ; non-equi join : SELECT DT RIGHT JOIN X ON DT$id = X$id AND DT$y <= x$foo
dt[x, on=.(x, v >= v),       ; non-equi join with by=.EACHI
      sum(y) * foo,
      by = .EACHI]
```
* При соединении таблиц в синтаксисе dt[x, on='id'] дополнительный аргумент:
  * `nomatch = NA`          реализует *outer join*
  * `nomatch = NULL`        реализует *inner join*
  * `mult = "first"|"last"` выберет из каждой группы первую|последнюю запись

Для разноименных столбцов соединения используется синтаксис `on = .(col2 = COL4)`.\
Условие соединения может быть сложным выражением, напр., `on = .(col2 = COL4, col6 > COL8))`.\
При операторном соединении рекомендуется также указывать аргумент `j` для возвращения только нужных столбцов, поскольку в противном случае возвращаются *все* столбцы обеих таблиц.

  
[How to do joins with data.table](https://gist.github.com/nacnudus/ef3b22b79164bbf9c0ebafbf558f22a0)

## Специальные переменные
`.SD`, `.BY`, `.N`, `.I`, `.GRP` и `.NGRP` — read-only переменные, которые могут использоваться в `j`.\
`.N` также может использоваться в `i`.\
`.EACHI` используется только в выраженияз `by = .EACHI` или `keyby = .EACHI`.
### Значения специальных переменных
* `.SD` — объект data.table, содержащий подмноджество столбцов данных для каждой группы, исключая столбцы, используемые в `by` или `keyby`.
* `.BY` — список векторов единичной длины для каждой группы в `by`. Может быть полезен для организации ветвления в `if()` в зависимости от значения групповой переменной.
* `.N` — целое число равное числу строк в группе.
* `.I` — целочисленыый вектор равный для каждой группы `seq_len(nrow(x))`.
* `.GRP` — целочисленный счетчик групп, равный 1 для первой группы, 2 для второй группы и т.д.
* `.NGRP` — целое число равное числу групп.
* `.EACHI` — не используется сам по себе и его значение равно `NULL`. Позволяет осуществить *grouping-by-each-row-of-i* путем указания `by = .EACHI` или `keyby = .EACHI`.

## Дополнительные замечания
* Синтаксис `dt[ ][ ][ ]` позволяет строить последовательные подзапросы для получения данных.
* Обращение к элементам data.table, как правило, возвращает объект data.table
* Обращение к столбцам по их номерам (как при работе с data.frame) не рекомендуется — следует указывать имена столбцов.
* `dt[2]` вернет *data.table*, содержащий вторую строку (`df[2]` вернет второй столбец как *data.frame*).
* `dt[2, 2]` вернет *data.table*, содержащий одно значение второй строки второго столбца (`df[2, 2]` вернет вектор размера 1).
* `dt[["Col2"]]` или `dt[[2]]` : самый быстрый способ вернуть вектор-столбец из объекта data.table.
* `dt[, X + Y]` вернет вектор (т.к. названия столбцов трактуются как обычные переменные), тогда как `dt[, .(X + Y)]` вернет *data.table*.
* Чтобы вернуть столбцы, названия которых заданы значениями переменной `x` для data.frame достаточно указать `df[, x]`. Для data.table необходимо использовать `dt[, x, with = FALSE]` (иначе будет осуществлен поиск столбца с названием `x`). Чтобы вернуть столбец, название которого задано переменной `x` можно использовать синтаксис `dt[[x]]`.

Опция `options(datatable.WhenJisSymbolThenCallingScope=TRUE)` изменяет поведение по умолчанию для data.table на поведение, аналогичное поведению data.frame.
* `X[Y, sum(foo*bar), by = .EACHI]` : группирует результат соединения по каждому значения ключа

* `dt[NA]` вернет одну строку со значениями `NA` для всех столбцов. То же самое вернет `dt[i]`, если значение `i` превышает число строк в таблице.
* `dt[0]` или `dt[FALSE]` вернут пустую таблицу той же структуры, что и `dt`.
* Чтобы получить вывод таблицы, содержащей операцию `:=` нужно добавть в конце `[]`.
* Создание индекса в таблице не увеличивает потребность в RAM, поскольку при этом производится только пересортировка строк и помечаются столбцы, входящие в индекс (все аналогично clustered index в SQL). Вторичные индексы занимают дополнительные `4*nrow` байт в памяти. Как правило, они создаются автомитически при задании логических условий в `i`, использующих операторы `==` и `%in%`.
* Для таблицы, загруженной с помощью `readRDS()` или `load()`, рекомендуется вызввать функцию `setalloccol()`, т.к. сохранение таблицы в бинарном формате нарушает оптимизацию ее размещения в RAM.



## Examples
```r
; чтение из файла столбцов col2 и col4
dt <- fread("file.csv", sep = ";", select = c("col2", "col4"))

; преобразование из длинного формата в широкий
cast(dt, id ~ y, value.var = c("x", "z"))  ; `id` станет идентификатором строк, значения `y` названиями столбцов, значения 'x' и 'z' заполнят ячейки

; преобразование из широкого формата в длинный
;   id – столбец-идентификатор строк
;   measure.vars – столбцы для заполнения ячеек
;   variable.name – названия для новых столбцов
;   value.name – derived from old headers
melt(dt, id.vars = c("id"), measure.vars = patterns("^a", "^b"), variable.name = "y", value.name = c("a", "b"))

; вычисляет число записей по месяцам и сортирует результат по убыванию
dt[, .N, by = month] [order(-N)]

; найти три месяца с наибольшим средним значением x
dt[, .(mean_x = mean(x, na.rm = TRUE)), by = month][order(-mean_x)][1:3]

; перенумеровать строки внутри групп, определяемых столбцом col2
dt[, GID := 1:.N, by = col2]

; применить функцию mean к заданным столбцам и вернуть результат как data.table
dt[,  lapply(.SD, mean), .SDcols = c("col1", "col2)"]

; добавить в таблицу столбцы со средним значением указанных переменных
cols <- c("col2", "col4")
dt[, paste0("m_", cols) := lapply(.SD, mean), .SDcols = cols]

; создать столбец, полученный сдвигом на одно значение вверх из столбца col1 внутри групп, образованных столбцом col2
dt[, col5 := shift(col1, 1, type = "lead"), by = col2]
```

## FAQ
* `dt[...]` всегда возвращает объект *data.table*, если параметры `i` и `j` указаны числами, напр., `dt[, 2]` или `dt[1, 3]`, либо, если параметр `j` задан списком. Чтобы вернуть отдлельный столбец как вектор нужно использовать `dt$colName`, `dt[["colName"]]` или `dt[, colname]`. В последнем случае имя столбца используется как обычная переменная, поэтому возвращается именно вектор (`dt[, "colName"]` вернет *data.table*). То же самое будет, напр., в случае `dt[, col1 * col2]`.
* В качестве `i` и `j` могут использоваться любые выражения, напр., `dt[x > 100, plot(y, z)]`.
* Выражение `dt[0]` вернет новую пустую таблицу со структурой таблицы `dt`.

## References
* [Enhanced data.frame](https://rdatatable.gitlab.io/data.table/reference/data.table.html)
* [Frequently Asked Questions about data.table](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-faq.html#why-does-xy-return-all-the-columns-from-y-too-shouldnt-it-return-a-subset-of-x)
* [data.table | Documentation on GitHub](https://github.com/Rdatatable/data.table/wiki)
* [R – Data.Table Rolling Joins](https://www.gormanalysis.com/blog/r-data-table-rolling-joins/)
* [Data manipulations | Филипп Управителев](https://webinars.rintro.ru/data-manipulations.html#dt1dt2-merge)

