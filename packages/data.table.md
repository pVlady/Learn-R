# package: data.table

* Обращение к элементам data.table, как правило, возвращает объект data.table
* Обращение к столбцам по их номерам (как при работе с data.frame) не рекомендуется — следует указывать имена столбцов.
* `dt[2]` вернет *data.table*, содержащий вторую строку (`df[2]` вернет второй столбец как *data.frame*).
* `dt[2, 2]` вернет *data.table*, содержащий одно значение второй строки второго столбца (`df[2, 2]` вернет вектор размера 1).
* `dt[["Col2"]]` или `dt[[2]]` : самый быстрый способ вернуть вектор-столбец из объекта data.table.
* `dt[, X + Y]` вернет вектор (т.к. названия столбцов трактуются как обычные переменные), тогда как `dt[, .(X + Y)]` вернет *data.table*.
* Для использования синтаксиса data.frame в объектах data.table в операторе `[ ]` необходимо указать аргумент `with = FALSE`.
* Чтобы вернуть столбцы, названия которых заданы значениями переменной `x` для data.frame достаточно указать `df[, x]`. Для data.table необходимо использовать `dt[, x, with = FALSE]` (иначе будет осуществлен поиск столбца с названием `x`). Чтобы вернуть столбец, название которого задано переменной `x` можно использовать синтаксис `dt[[x]]`.
Опция `options(datatable.WhenJisSymbolThenCallingScope=TRUE)` изменяет поведение по умолчанию для data.table на поведение, аналогичное поведению data.frame.
* `X[Y, sum(foo*bar), by = .EACHI]` : группирует результат соединения по каждому значения ключа

### Выборка столбцов
```r
dt[ , .(x, y, z)]
dt[, c("x","y","z")]
dt[, cols, with = FALSE)   ; вернуть столбцы, названия которых заданы переменной cols
```
* `.SD` : *Subset of the Data.table* – ссылается на все столбцы, за исколючением столбцов группировки. Может быть переопределено аргументом `SDcols`.
* Группирующая переменная, если используется в выражении `j`, всегда имеет размерность 1 и содержит значение группы.
* Чтобы вывести нужное количесво строк функцией `print()` можно использовать `print(dt, topn = 20)`.
 
>*Для получения некоторого набора элементов из массива в виде вектора необходимо использовать синтаксис* `dt[mx]`*, где* `mx` *это матрица с количеством столбцов равным количеству индексов в массиве, а каждая строка матрицы представляет собой индексы извлекаемых элементов. Вместо числовых индексов также можно использовать имена для строк и столбцов матрицы.*

* При соединении таблиц аргумент `nomatch = NA` осуществит *outer join*, аргумент `nomatch = NULL` — *inner join*, аргумент `mult = "first"|"last"` выберет из каждой группы первую|последнюю запись.
* `dt[NA]` вернет одну строку со значениями `NA` для всех столбцов. То же самое вернет `dt[i]`, если значение `i` превышает число строк в таблице.
* `dt[0]` или `dt[FALSE]` вернут пустую таблицу той же структуры, что и `dt`.
* Чтобы получить вывод таблицы, содержащей операцию `:=` нужно добавть в конце `[]`.
* Создание индекса в таблице не увеличивает потребность в RAM, поскольку при этом производится только пересортировка строк и помечаются столбцы, входящие в индекс (все аналогично clustered index в SQL). Вторичные индексы занимают дополнительные `4*nrow` байт в памяти. Как правило, они создаются автомитически при задании логических условий в `i`, использующих операторы `==` и `%in%`.
* Для таблицы, загруженной с помощью `readRDS()` или `load()`, рекомендуется вызввать функцию `setalloccol()`, т.к. сохранение таблицы в бинарном формате нарушает оптимизацию ее размещения в RAM.

## Дополнительншые аргументы в операторе `[`
* `mult = "first"|"last"` : позволяет выбрать первую|последнюю запись в группе
* roll
* .EACHI
* SDcols
* `with` : если = FALSE, то используется синтаксис data.frame
* `nomatch = NA|NULL` : используется для изменения типа соединения таблиц `outer join|inner join`.

## References
[data.table | Documentation on GitHub](https://github.com/Rdatatable/data.table/wiki)

